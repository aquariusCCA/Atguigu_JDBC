# 1. 批量执行SQL语句
> 当需要成批插入或者更新记录时，可以采用 Java 的批量更新机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率。

### JDBC 的批量处理语句包括下面三个方法：
1. addBatch(String)：添加需要批量处理的 SQL 语句或是参数
2. executeBatch()：执行批量处理语句
3. clearBatch() : 清空缓存的数据

### 通常我们会遇到两种批量执行 SQL 语句的情况：
1. 多条 SQL 语句的批量处理
2. 一个 SQL 语句的批量传参

### 語句後面不能添加分號 `;`
在 JDBC 中，**SQL 語句**本身是直接交給資料庫去執行的。  
如果你在程式中寫的 SQL 字串是這樣：

```java
String sql = "insert into t_user (account,password,nickname) values (?,?,?);";
```

那麼 JDBC 在後端真正傳送的 SQL 語句是包含 `;` 的。  
但是：

- **JDBC** 和 **MySQL JDBC Driver**（像 `com.mysql.cj.jdbc.Driver`）在進行 **批量優化**（`rewriteBatchedStatements=true`）的時候，
- 它們會把多個 SQL 拼成一條大語句，例如：

  ```sql
  insert into t_user (account,password,nickname) values ('a','b','c'),('d','e','f'),('g','h','i')
  ```

這樣可以一次插入多筆數據，提高效率（避免多次網路傳輸）。

🔵 **如果 SQL 字串裡有分號**：

- JDBC 驅動器在「拼接」的時候無法正常組合，因為 **分號表示結束語句**！
- 例如：

  ```sql
  insert into t_user (account,password,nickname) values ('a','b','c');insert into t_user (account,password,nickname) values ('d','e','f');
  ```

這不是一條語法正確的 SQL，而是兩條分開的語句，會導致**批量執行失敗**！

✅ 簡單說：
- **批量時，每個 SQL 語句不能帶分號；不然會破壞拼接邏輯！**
- **單條執行的時候可以加，但批量操作時禁止。**

# 2. 高效的批量插入
## 数据库中提供一个 goods 表。创建如下：

```sql
CREATE TABLE goods(
    id INT PRIMARY KEY AUTO_INCREMENT,
    NAME VARCHAR(20)
);
```

## 举例：向数据表中插入 20000 条数据

### 实现层次一：使用 Statement

```java
@Test
public void testInsert1() throws Exception{
    long start = System.currentTimeMillis();
    Connection conn = JDBCUtils.getConnection();
    Statement st = conn.createStatement();
    for(int i = 1;i <= 20000;i++){
        String sql = "insert into goods(name) values('name_" + i + "')";
        st.executeUpdate(sql);
    }
    long end = System.currentTimeMillis();
    System.out.println("花费的时间为：" + (end - start));
}
```

### 实现层次二：使用 PreparedStatement
> 相對於方式一來說, 方式二的效率肯定是比較好的因為 Statement 每次都要加載新的 sql 語句，而 PreparedStatement 都是使用同一個模板，變動的只有佔位符。

```java
@Test
public void testInsert2() {
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        long start = System.currentTimeMillis();

        conn = JDBCUtils.getConnection();

        String sql = "insert into goods(name)values(?)";
        ps = conn.prepareStatement(sql);
        for (int i = 1; i <= 20000; i++) {
            ps.setObject(1, "name_" + i);

            ps.execute();
        }

        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start)); // 50102
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        JDBCUtils.closeResource(conn, ps);
    }
}
```

### 实现层次三 : 使用 addBatch()、executeBatch()、clearBatch()
> mysql 服务器默认是关闭批处理的，我们需要通过一个参数，让 mysql 开启批处理的支持。 
>
> ​	將 `?rewriteBatchedStatements=true` 写在配置文件的 url 后面。

```java
@Test
public void testInsert3() {
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        long start = System.currentTimeMillis();

        conn = JDBCUtils.getConnection();

        String sql = "insert into goods(name) values(?)";
        ps = conn.prepareStatement(sql);

        for (int i = 1; i <= 1000000; i++) {
            ps.setObject(1, "name_" + i);

            //1."積攢"sql
            ps.addBatch();

            if (i % 500 == 0) {
                //2.执行batch
                ps.executeBatch();

                //3.清空batch
                ps.clearBatch();
            }
        }

        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start)); // 19509
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        JDBCUtils.closeResource(conn, ps);
    }
}
```

### 实现层次四 : 设置连接不允许自动提交数据
```java
@Test
public void testInsert4() {
    Connection conn = null;
    PreparedStatement ps = null;
    try {
        long start = System.currentTimeMillis();

        conn = JDBCUtils.getConnection();

        //设置不允许自动提交数据
        conn.setAutoCommit(false);

        String sql = "insert into goods(name)values(?)";
        ps = conn.prepareStatement(sql);
        for (int i = 1; i <= 1000000; i++) {
            ps.setObject(1, "name_" + i);

            //1."攒"sql
            ps.addBatch();

            if (i % 500 == 0) {
                //2.执行batch
                ps.executeBatch();

                //3.清空batch
                ps.clearBatch();
            }
        }

        //提交数据
        conn.commit();

        long end = System.currentTimeMillis();
        System.out.println("花费的时间为：" + (end - start)); // 11280
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        JDBCUtils.closeResource(conn, ps);
    }
}
```

