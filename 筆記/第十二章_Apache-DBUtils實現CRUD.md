# 1. Apache-DBUtils简介
> **commons-dbutils** 是 Apache 组织提供的一个开源 JDBC工具类库，它是对 JDBC 的简单封装，学习成本极低， 并且使用 dbutils 能极大简化 jdbc 编码的工作量，同时也不会影响程序的性能。

# 2. 主要 API 的使用
![](images/a389e9fa5d64d0df01bfbb2bcc14e774.png)

## 2.1 DbUtils
![](images/64df25f7834d0fdeb8fcc69cd2621582.png)

- DbUtils ：提供如关闭连接、装载 JDBC 驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：
  - public static void close(…) throws java.sql.SQLException： DbUtils 类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是 NULL，如果不是的话，它们就关闭 Connection、Statement 和 ResultSet。
  - public static void closeQuietly(…) : 这一类方法不仅能在 Connection、Statement 和 ResultSet 为 NULL情况下避免关闭，还能隐藏一些在程序中抛出的 SQLEeception。
  - public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务， 然后关闭连接。
  - public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在 关闭连接时不抛出 SQL 异常。
  - public static void rollback(Connection conn)throws SQLException：允许 conn 为 null，因为方法内部做了判断。
  - public static void rollbackAndClose(Connection conn)throws SQLException
  - rollbackAndCloseQuietly(Connection)
  - public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册 JDBC 驱动程 序，如果成功就返回 true。使用该方法，你不需要捕捉这个异常 ClassNotFoundException。

```java
import java.sql.Connection;
import java.sql.SQLException;

import org.apache.commons.dbutils.DbUtils;
import org.apache.commons.dbutils.QueryRunner;
import org.junit.Test;

public class TestApacheDBUtils {
	@Test
	public void testTransaction() {
	    Connection conn = null;
	    try {
	    	//提供數據庫操作一系列重載的 update() 和 query()
	        QueryRunner runner = new QueryRunner(); 
	        
	        //獲取連接
	        conn = JDBCUtils.getConnection();
	        conn.setAutoCommit(false); // 開啟手動事務

	        String sql = "update user_table set balance = balance - 100 where `user` = ?";
	        int subCount = runner.update(conn, sql, "AA");
	        System.out.println("subCount: " + subCount);

	        // 模拟异常
	        System.out.println(10 / 0);

	        String sql2 = "update user_table set balance = balance + 100 where `user` = ?";
	        int addCount = runner.update(conn, sql2, "BB");
	        System.out.println("addCount: " + addCount);

	        conn.commit(); // 提交事務
	    } catch (Exception e) {
	        try {
	            DbUtils.rollback(conn);
	        } catch (SQLException ex) {
	            System.err.println("事務回滾失敗");
	            ex.printStackTrace();
	        }
	        throw new RuntimeException("事務執行異常", e);
	    } finally {
	        DbUtils.closeQuietly(conn); // 靜默關閉連接，不再拋出異常
	    }
	}

}
```

## 2.2 QueryRunner 类
> 该类简单化了 SQL 查询，它与 ResultSetHandler 组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。

### QueryRunner 类提供了两个构造器：
- 默认的构造器
- 需要一个 javax.sql.DataSource 来作参数的构造器

### QueryRunner类的主要方法：
- 更新
    - public int update(Connection conn, String sql, Object... params) throws SQLException:用来执行 一个更新（插入、更新或删除）操作。
    - ...
- 插入
    - public T insert(Connection conn,String sql,ResultSetHandler rsh, Object... params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys. 返回值: An object generated by the handler.即自动生成的 键值
    - ...
- 批处理
    - public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句
    - public T insertBatch(Connection conn,String sql,ResultSetHandler rsh,Object[][] params)throws SQLException：只支持INSERT语句
    - ...
- 查询
    - public Object query(Connection conn, String sql, ResultSetHandler rsh,Object... params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句 的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。
    - ...

### 测试添加 :

```java
@Test
public void testInsert() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務
        
        String sql = "insert into customers(name,email,birth)values(?,?,?)";

        //返回影響了幾行紀錄
        //如果你是事務中的一部分操作就需要把連接傳進去, 因為必須確保連接都是使用同一個
        int insertCount = runner.update(conn, sql, "蔡徐坤", "caixukun@126.com", "1997-09-08");
        
        conn.commit(); // 提交事務
        System.out.println("添加了" + insertCount + "条记录");
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

### 测试删除 :

```java
@Test
public void testDelete() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務
        
        String sql = "delete from customers where id = ?";

        //返回影響了幾行紀錄
        //如果你是事務中的一部分操作就需要把連接傳進去, 因為必須確保連接都是使用同一個
        int deleteCount = runner.update(conn, sql, 36);
        
        conn.commit(); // 提交事務
        System.out.println("刪除了" + deleteCount + "条记录");
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

## 2.3 ResultSetHandler 接口及实现类
> 该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。

- ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。

### 接口的主要实现类：
- ArrayHandler：把结果集中的第一行数据转成对象数组。
- ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到 List 中。 
- BeanHandler：将结果集中的第一行数据封装到一个对应的 JavaBean 实例中。 
- BeanListHandler：将结果集中的每一行数据都封装到一个对应的 JavaBean 实例中，存放到 List 里。 
- ColumnListHandler：将结果集中某一列的数据存放到 List 中。 
- KeyedHandler(name)：将结果集中的每一行数据都封装到一个 Map 里，再把这些 map 再存到一个 map 里，其 key 为指定的 key。 
- MapHandler：将结果集中的第一行数据封装到一个 Map 里，key 是列名，value 就是对应的值。 
- MapListHandler：将结果集中的每一行数据都封装到一个 Map 里，然后再存放到 List。
- ScalarHandler：查询单个值对象。


### BeanHander 測試 :
```java
// BeanHander:是ResultSetHandler接口的实现类，用于封装表中的一条记录。
@Test
public void testQueryInstance() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務

        String sql = "select id,name,email,birth from customers where id = ?";

        //将结果集中的第一行数据封装到一个对应的JavaBean实例中
        BeanHandler<Customer> handler = new BeanHandler<>(Customer.class);

        //如果你是事務中的一部分操作就需要保連接傳進去, 因為必須確保連接都是使用同一個
        Customer customer = runner.query(conn, sql, handler, 35);
        
        conn.commit(); // 提交事務
        System.out.println(customer);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

### BeanListHandler 測試 :
```java
// BeanListHandler:是ResultSetHandler接口的实现类，用于封装表中的多条记录构成的集合。
@Test
public void testQueryList() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務
        
        String sql = "select id,name,email,birth from customers where id < ?";

        //将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里
        BeanListHandler<Customer> handler = new BeanListHandler<>(Customer.class);

        //如果你是事務中的一部分操作就需要保連接傳進去, 因為必須確保連接都是使用同一個
        List<Customer> list = runner.query(conn, sql, handler, 23);
        
        conn.commit(); // 提交事務
        list.forEach(System.out::println);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

### MapHander 測試 :
```java
//MapHander:是ResultSetHandler接口的实现类，对应表中的一条记录。将字段及相应字段的值作为map中的key和value
@Test
public void testMapHander() {
    Connection conn = null;
    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務

        conn = JDBCUtils.getConnection();
        String sql = "select id,name,email,birth from customers where id = ?";

        MapHandler handler = new MapHandler();

        Map<String, Object> map = runner.query(conn, sql, handler, 30);
        
        conn.commit(); // 提交事務
        System.out.println(map);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

### MapListHander 測試 :

```java
// MapListHander:是ResultSetHandler接口的实现类，对应表中的多条记录。将字段及相应字段的值作为map中的key和value。将这些map添加到List中
@Test
public void testMapListHander() {
    Connection conn = null;
    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務
        
        String sql = "select id,name,email,birth from customers where id < ?";

        MapListHandler handler = new MapListHandler();
        List<Map<String, Object>> list = runner.query(conn, sql, handler, 23);
        
        conn.commit(); // 提交事務
        list.forEach(System.out::println);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

### ScalarHandler 測試 :

```java
// ScalarHandler:用于查询特殊值
@Test
public void testScalarHandler() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務

        String sql = "select count(*) from customers";

        ScalarHandler handler = new ScalarHandler();

        Long count = (Long) runner.query(conn, sql, handler);
        
        conn.commit(); // 提交事務
        System.out.println(count);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}

@Test
public void testScalarHandler2() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務

        String sql = "select max(birth) from customers";

        ScalarHandler handler = new ScalarHandler();
        Date maxBirth = (Date) runner.query(conn, sql, handler);
        
        conn.commit(); // 提交事務
        System.out.println(maxBirth);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

### ResultSetHandler 測試 :

```java
// 自定义ResultSetHandler的实现类
@Test
public void testResultSetHandler() {
    Connection conn = null;

    try {
        //提供數據庫操作一系列重載的 update() 和 query()
        QueryRunner runner = new QueryRunner();

        //獲取連接
        conn = JDBCUtils.getConnection();
        conn.setAutoCommit(false); // 開啟手動事務

        String sql = "select id,name,email,birth from customers where id = ?";

        //匿名實現類
        ResultSetHandler<Customer> handler = new ResultSetHandler<Customer>() {
            //這個方法返回的返回值, 就是要數據將要封裝的對象
            @Override
            public Customer handle(ResultSet rs) throws SQLException {
                // rs: 就是對應查詢表的結果集
                if (rs.next()) {
                    int id = rs.getInt("id");
                    String name = rs.getString("name");
                    String email = rs.getString("email");
                    Date birth = rs.getDate("birth");
                    Customer customer = new Customer(id, name, email, birth);
                    return customer;
                }
                return null;
            }
        };

        Customer customer = runner.query(conn, sql, handler, 30);
        
        conn.commit(); // 提交事務
        System.out.println(customer);
    } catch (Exception e) {
        try {
            DbUtils.rollback(conn);
        } catch (SQLException ex) {
            System.err.println("事務回滾失敗");
            ex.printStackTrace();
        }
        throw new RuntimeException("事務執行異常", e);
    } finally {
        DbUtils.closeQuietly(conn);
    }
}
```

# 3. 升級以後的 Dao 及相關類的測試
## BaseDao
```java
package apacheDBUtils;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.List;

import org.apache.commons.dbutils.QueryRunner;
import org.apache.commons.dbutils.handlers.BeanHandler;
import org.apache.commons.dbutils.handlers.BeanListHandler;
import org.apache.commons.dbutils.handlers.ScalarHandler;

/**
 * BaseDAO: 封装针对于数据表的通用的操作 (Apache-DBUtils版本)
 */
public abstract class BaseDAO<T> {

    private Class<T> clazz = null;
    private QueryRunner queryRunner = new QueryRunner();

    {
        // 获取当前BaseDAO的子类继承的父类的泛型
        Type genericSuperclass = this.getClass().getGenericSuperclass();
        ParameterizedType paramType = (ParameterizedType) genericSuperclass;
        Type[] typeArguments = paramType.getActualTypeArguments();
        clazz = (Class<T>) typeArguments[0];
    }

    /**
     * 通用的增删改操作
     */
    public int update(Connection conn, String sql, Object... args) {
        try {
            return queryRunner.update(conn, sql, args);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 通用的查询操作，返回一条记录
     */
    public T getInstance(Connection conn, String sql, Object... args) {
        try {
            return queryRunner.query(conn, sql, new BeanHandler<>(clazz), args);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 通用的查询操作，返回多条记录
     */
    public List<T> getForList(Connection conn, String sql, Object... args) {
        try {
            return queryRunner.query(conn, sql, new BeanListHandler<>(clazz), args);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * 用于查询特殊值的通用方法 (單值，比如 count、max、min)
     */
    public <E> E getValue(Connection conn, String sql, Object... args) {
        try {
            return queryRunner.query(conn, sql, new ScalarHandler<>(), args);
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }
}
```

## CustomerDao
```java
package apacheDBUtils;

import java.sql.Connection;
import java.sql.Date;
import java.util.List;

import bean.Customer;

/*
 * 此接口用于规范针对于customers表的常用操作
 */
public interface CustomerDAO {
    /**
     * @param conn
     * @param cust
     * @Description 将cust对象添加到数据库中
     */
    void insert(Connection conn, Customer cust);

    /**
     * @param conn
     * @param id
     * @Description 针对指定的id，删除表中的一条记录
     */
    void deleteById(Connection conn, int id);

    /**
     * @param conn
     * @param cust
     * @Description 针对内存中的cust对象，去修改数据表中指定的记录
     */
    void update(Connection conn, Customer cust);

    /**
     * @param conn
     * @param id
     * @Description 针对指定的id查询得到对应的Customer对象
     */
    Customer getCustomerById(Connection conn, int id);

    /**
     * @param conn
     * @return
     * @Description 查询表中的所有记录构成的集合
     */
    List<Customer> getAll(Connection conn);

    /**
     * @param conn
     * @return
     * @Description 返回数据表中的数据的条目数
     */
    Long getCount(Connection conn);

    /**
     * @param conn
     * @return
     * @Description 返回数据表中最大的生日
     */
    Date getMaxBirth(Connection conn);
}
```

## CustomerDAOImpl
```java
package apacheDBUtils;



import java.sql.Connection;
import java.sql.Date;
import java.util.List;

import bean.Customer;

public class CustomerDAOImpl extends BaseDAO<Customer> implements CustomerDAO {

    @Override
    public void insert(Connection conn, Customer cust) {
        String sql = "INSERT INTO customers(name, email, birth) VALUES(?, ?, ?)";
        update(conn, sql, cust.getName(), cust.getEmail(), cust.getBirth());
    }

    @Override
    public void deleteById(Connection conn, int id) {
        String sql = "DELETE FROM customers WHERE id = ?";
        update(conn, sql, id);
    }

    @Override
    public void update(Connection conn, Customer cust) {
        String sql = "UPDATE customers SET name = ?, email = ?, birth = ? WHERE id = ?";
        update(conn, sql, cust.getName(), cust.getEmail(), cust.getBirth(), cust.getId());
    }

    @Override
    public Customer getCustomerById(Connection conn, int id) {
        String sql = "SELECT id, name, email, birth FROM customers WHERE id = ?";
        return getInstance(conn, sql, id);
    }

    @Override
    public List<Customer> getAll(Connection conn) {
        String sql = "SELECT id, name, email, birth FROM customers";
        return getForList(conn, sql);
    }

    @Override
    public Long getCount(Connection conn) {
        String sql = "SELECT COUNT(*) FROM customers";
        return getValue(conn, sql);
    }

    @Override
    public Date getMaxBirth(Connection conn) {
        String sql = "SELECT MAX(birth) FROM customers";
        return getValue(conn, sql);
    }
}
```

## 測試
```java
package apacheDBUtils;

import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.fail;

import java.sql.Connection;
import java.sql.Date;
import java.time.LocalDate;
import java.util.List;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import bean.Customer;

public class CustomerDAOImplTest {

    private CustomerDAO customerDAO;
    private Connection conn;

    @BeforeEach
    void setUp() {
        customerDAO = new CustomerDAOImpl();
        conn = JDBCUtils.getConnection();
    }

    @AfterEach
    void tearDown() {
        JDBCUtils.closeResource(conn, null, null);
    }

    @Test
    void testInsert() {
        try {
            conn.setAutoCommit(false);

            Customer cust = new Customer(1, "于小飞", "xiaofei@126.com", new Date(43534646435L));
            customerDAO.insert(conn, cust);

            conn.commit();
            System.out.println("Insert success.");
        } catch (Exception e) {
            e.printStackTrace();
            rollback(conn);
            fail("Insert failed.");
        }
    }

    @Test
    void testUpdate() {
        try {
            conn.setAutoCommit(false);

            Customer cust = new Customer(1, "Jerry", "jerry@example.com", Date.valueOf(LocalDate.of(1990, 8, 8)));
            customerDAO.update(conn, cust);

            conn.commit();
            System.out.println("Update success.");
        } catch (Exception e) {
            e.printStackTrace();
            rollback(conn);
            fail("Update failed.");
        }
    }

    @Test
    void testDeleteById() {
        try {
            conn.setAutoCommit(false);

            customerDAO.deleteById(conn, 3);

            conn.commit();
            System.out.println("Delete success.");
        } catch (Exception e) {
            e.printStackTrace();
            rollback(conn);
            fail("Delete failed.");
        }
    }

    @Test
    void testGetCustomerById() {
        try {
            Customer customer = customerDAO.getCustomerById(conn, 1);
            assertNotNull(customer);
            System.out.println(customer);
        } catch (Exception e) {
            e.printStackTrace();
            fail("Query by ID failed.");
        }
    }

    @Test
    void testGetAll() {
        try {
            List<Customer> list = customerDAO.getAll(conn);
            assertNotNull(list);
            list.forEach(System.out::println);
        } catch (Exception e) {
            e.printStackTrace();
            fail("Get all customers failed.");
        }
    }

    @Test
    void testGetCount() {
        try {
            Long count = customerDAO.getCount(conn);
            assertNotNull(count);
            System.out.println("Total records: " + count);
        } catch (Exception e) {
            e.printStackTrace();
            fail("Get count failed.");
        }
    }

    @Test
    void testGetMaxBirth() {
        try {
            Date maxBirth = customerDAO.getMaxBirth(conn);
            assertNotNull(maxBirth);
            System.out.println("Max birthday: " + maxBirth);
        } catch (Exception e) {
            e.printStackTrace();
            fail("Get max birth failed.");
        }
    }

    private void rollback(Connection conn) {
        try {
            if (conn != null) {
                conn.rollback();
                System.out.println("Transaction rolled back.");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```